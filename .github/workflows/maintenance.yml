name: Maintenance Window

on:
  workflow_dispatch:
    inputs:
      action:
        description: open | deploy | close
        required: true
        default: "deploy"
      vm_name:
        description: VM name
        required: false
        default: "bfl-onprem"
      reserve_ip:
        description: "Use reserved IP id (optional). Empty = ephemeral"
        required: false
        default: ""
      stop_on_close:
        description: "Stop VM on close (yes/no)"
        required: false
        default: "no"

permissions:
  contents: read

env:
  YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
  YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
  YC_ZONE: ${{ secrets.YC_ZONE }}
  SA_KEY_JSON: ${{ secrets.YC_SA_KEY_JSON }}

jobs:
  maint:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Setup YC CLI
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y && sudo apt-get install -y jq
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          echo "${HOME}/yandex-cloud/bin" >> $GITHUB_PATH
          echo "$SA_KEY_JSON" > sa.json
          yc config profile create gha-maint || true
          yc config profile activate gha-maint
          yc config set service-account-key sa.json
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"
          yc config set compute-default-zone "$YC_ZONE"

      - name: Resolve NIC index & NAT state
        id: nic
        shell: bash
        env:
          VM: ${{ github.event.inputs.vm_name }}
        run: |
          set -euo pipefail
          INFO="$(yc compute instance get --name "$VM" --format json)"
          IDX="$(jq -r '.network_interfaces[0].index' <<<"$INFO")"
          HAS_NAT="$(jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat != null' <<<"$INFO")"
          PUB_IP="$(jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat.address // ""' <<<"$INFO")"
          echo "idx=$IDX" >> $GITHUB_OUTPUT
          echo "has_nat=$HAS_NAT" >> $GITHUB_OUTPUT
          echo "pub_ip=$PUB_IP" >> $GITHUB_OUTPUT

      - name: OPEN — attach NAT (public IP) for the window
        if: ${{ inputs.action == 'open' || inputs.action == 'deploy' }}
        shell: bash
        env:
          VM: ${{ github.event.inputs.vm_name }}
          RES_ID: ${{ github.event.inputs.reserve_ip }}
        run: |
          set -euo pipefail
          if [[ "${{ steps.nic.outputs.has_nat }}" == "true" ]]; then
            echo "NAT already attached: ${{ steps.nic.outputs.pub_ip }}"
          else
            if [[ -n "$RES_ID" ]]; then
              yc compute instance add-one-to-one-nat --name "$VM" --network-interface-index ${{ steps.nic.outputs.idx }} --address "$RES_ID"
            else
              yc compute instance add-one-to-one-nat --name "$VM" --network-interface-index ${{ steps.nic.outputs.idx }}
            fi
            sleep 2
            NEW_IP="$(yc compute instance get --name "$VM" --format json | jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat.address')"
            echo "Public IP attached: $NEW_IP"
            echo "pub_ip=$NEW_IP" >> $GITHUB_OUTPUT
          fi

      - name: DEPLOY — compose pull/up + smoke via SSH tunnel
        if: ${{ inputs.action == 'deploy' }}
        shell: bash
        env:
          VM: ${{ github.event.inputs.vm_name }}
        run: |
          set -euo pipefail
          AUTH="$(yc compute instance get --name "$VM" --format json | jq -r '.metadata_options.sshAuthorization // .serial_port_settings.ssh_authorization // ""' | tr '[:lower:]' '[:upper:]')"
          if [[ "$AUTH" == "OS_LOGIN" ]]; then LOGIN="yc-user"; USE_KEY="no"; else LOGIN="ubuntu"; USE_KEY="yes"; fi
          echo "Auth=$AUTH Login=$LOGIN UseKey=$USE_KEY"
          KEY_OPT=()
          if [[ "$USE_KEY" == "yes" ]]; then
            KEY="$RUNNER_TEMP/m.key"; ssh-keygen -t ed25519 -N "" -C "gha-maint-$(date -u +%Y%m%dT%H%M%SZ)" -f "$KEY" >/dev/null
            ENTRY="${LOGIN}:$(cat "$KEY.pub")"
            printf "%s\n" "$ENTRY" > "$RUNNER_TEMP/ssh-keys.txt"
            yc compute instance add-metadata --name "$VM" --metadata-from-file ssh-keys="$RUNNER_TEMP/ssh-keys.txt"
            KEY_OPT=(-i "$KEY")
          fi
          yc compute ssh "${KEY_OPT[@]}" --name "$VM" --login "$LOGIN" -- \
            'set -e; cd ~/bfl-onprem && git pull --rebase || true; docker compose pull && docker compose up -d api redis || { docker compose ps; docker compose logs --no-color --tail 200; exit 1; }'
          nohup yc compute ssh "${KEY_OPT[@]}" --name "$VM" --login "$LOGIN" -- -N -L 127.0.0.1:8000:127.0.0.1:8000 >/tmp/ssh_tunnel.log 2>&1 &
          echo $! > /tmp/ssh_tunnel.pid; sleep 2; ss -tln | grep -q '127.0.0.1:8000'
          RETRY="--retry 5 --retry-all-errors --connect-timeout 3 --max-time 10 -sf"
          curl $RETRY http://127.0.0.1:8000/livez && curl $RETRY http://127.0.0.1:8000/readyz && curl $RETRY http://127.0.0.1:8000/api/health
          kill $(cat /tmp/ssh_tunnel.pid) 2>/dev/null || true
          if [[ "$USE_KEY" == "yes" ]]; then
            CURR="$(yc compute instance get --name "$VM" --full --format json | jq -r '.metadata["ssh-keys"] // ""')"
            ( printf "%s\n" "$CURR" | sed '/gha-maint-/d' > "$RUNNER_TEMP/ssh-keys.cleaned.txt" ) || true
            yc compute instance add-metadata --name "$VM" --metadata-from-file ssh-keys="$RUNNER_TEMP/ssh-keys.cleaned.txt"
          fi
          echo "Deploy OK"

      - name: CLOSE — detach NAT (and optionally stop VM)
        if: ${{ inputs.action == 'close' || inputs.action == 'deploy' }}
        shell: bash
        env:
          VM: ${{ github.event.inputs.vm_name }}
          STOP: ${{ github.event.inputs.stop_on_close }}
        run: |
          set -euo pipefail
          INFO="$(yc compute instance get --name "$VM" --format json)"
          HAS_NAT="$(jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat != null' <<<"$INFO")"
          if [[ "$HAS_NAT" == "true" ]]; then
            yc compute instance remove-one-to-one-nat --name "$VM" --network-interface-index 0
            echo "NAT detached"
          else
            echo "No NAT to detach"
          fi
          if [[ "$STOP" == "yes" ]]; then
            yc compute instance stop --name "$VM"
            echo "VM stopped"
          fi

      - name: Summary
        if: always()
        run: |
          echo "### Maintenance Window" >> $GITHUB_STEP_SUMMARY
          echo "- Action: **${{ inputs.action }}**" >> $GITHUB_STEP_SUMMARY
          echo "- VM: **${{ inputs.vm_name }}**" >> $GITHUB_STEP_SUMMARY
          echo "- Stop on close: **${{ inputs.stop_on_close }}**" >> $GITHUB_STEP_SUMMARY
